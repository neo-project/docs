# NEO 智能合约教程

阅读上一篇文档后，我们已经可以用 C# 在 Visual Studio 2015 中创建智能合约项目了。下面我们将对智能合约和 NeoVM（NEO 智能合约执行所在的虚拟机）中的知识点进行梳理。

## 智能合约的触发

NEO 的智能合约有两种触发方式：

1. 合约用户的鉴权：智能合约作为一个合约账户，当用户使用该合约账户里的一笔资产时，会触发该智能合约。

2. 手动发送交易调用智能合约：用户发送一笔交易（Invocation Transaction ）来触发一段智能合约的执行。


## 智能合约的类型

NEO 的智能合约有两个基类，FunctionCode 和 VerificationCode。

### 继承自 FunctionCode 的智能合约

继承于 FunctionCode 的智能合约可以编译好后发布到区块链中供其它用户使用。它相当于编程中的“函数”，即可以被“主函数”（上述的两种智能合约调用方式）调用，也能被“其它函数”（其它继承于 FunctionCode 的智能合约）调用。

继承自 FunctionCode 的智能合约的入口点是 `Main` 方法，返回值可以是 void、int、byte[]

本文是对上文的代码进行详述。

创建好的智能合约项目默认继承自 FunctionCode 入口点是 Main

```c#
public class Contract1 : FunctionCode
{
    public static void Main() // 注意 Main 方法要大写
    {
     // 继承于 FunctionCode 的智能合约可以编译好后发布到区块链中供其它用户使用
    }
}
```

### 继承自 VerificationCode 的智能合约

继承于 VerificationCode 的智能合约是可以在钱包客户端中生成合约地址，如果用户想使用该合约地址里的一笔资产（用户发送了一笔使用该合约地址资产的交易）便会触发该智能合约，合约执行并验证你是否可以动用这笔资产。

当该合约返回值为 true 时，验证通过， 用户可以花费这笔资产；

当该合约返回值为 false 时，验证失败，用户不可以花费这笔资产，这笔验证失败的交易无法被其它节点广播，也不会被共识节点确认。

继承自 VerificationCode 的智能合约的入口点是 `Verify` 方法，Verify 方法的返回值必须是 `bool` 类型。

```c#
public class Contract1 : VerificationCode 
{
    public static bool Verify()
    {
     return true;
    }
}
```

## NeoVM 虚拟机

NeoVM 就是执行 NEO 智能合约代码的虚拟机。我们这里所讲述的虚拟机概念比较狭义，并非是借助于操作系统对物理机器的一种模拟，这里的虚拟机与 vmware 或者 Hyper-V 不同，是针对具体语言所实现的虚拟机。

例如在 java 的 JVM 或者 .Net 的 CLR 中，java 或者 .Net 源码会被编译成相关字节码，然后在对应虚拟机上运行， JVM 或 CLR 会对这些字节码进行取指令，译码，执行，结果回写等操作，这些步骤和真实物理机器上的概念都很相似。相对应的二进制指令仍然是在物理机器上运行，物理机器从内存中取指令，通过总线传输到 CPU，然后译码、执行、结果存储。

### 虚拟机架构

![](/assets/neo-vm.jpg)

上图是 NEO 虚拟机（NeoVM）的系统架构图，其中虚线框中的部署是虚拟机的核心。

#### 执行引擎

左侧绿色的是虚拟机执行引擎（相当于 CPU），它可以执行常见的指令，例如流程控制、栈操作、位操作、算数运算、逻辑运算、密码学方法等，还可以通过系统调用，与互操作服务层（下文会介绍）进行交互。

#### 计算栈

中间灰色的部分是虚拟机的计算栈（相当于内存），如今虚拟机的实现方式有两种，基于栈的和基于寄存器的，这两种实现方式各有优劣，也都有标志性的产品。基于栈的虚拟机，有 JVM，CPython 以及 .Net CLR。基于寄存器的，有 Dalvik 以及 Lua5.0。基于栈的虚拟机有一个计算栈的概念，虚拟机在进行真正的运算时都是直接与计算栈（Evaluatio Stack）进行交互。

由于执行时默认都是从操作数栈上取数据，那么就无需指定操作数。例如，x86 汇编 ”ADD EAX, EBX”，就需要指定这次运算需要从什么地方取操作数，执行完结果存放在何处。但是基于栈的虚拟机的指令就无需指定，例如加法操作就一个简单的 ”Add” 就可以了，因为默认操作数存放在操作数栈上，直接从操作数栈上 pop 出两条数据直接执行加法运算，运算后的结果默认存放在栈顶。

#### 互操作服务层

右侧蓝色的部分是虚拟机的互操作服务层（相当于外设）。目前互操作服务层提供了账智能合约所能访问区块链数据的一些 API，利用这些 API，可以访问区块信息、交易信息、合约信息、资产信息等。

除此之外互操作服务层还为每个合约提供了一个持久化存储区的功能。NEO 的每个智能合约在创建的时候都可选地启用一个私有存储区，存储区是 key-value 形式的，NEO 智能合约由合约的被调用者决定持久化存储区的上下文，而非调用者来决定。当然，调用者需要将自己的存储上下文传给被调用者（即完成授权）后，被调用者才可以执行读写操作。

### 收费模式

NEO 智能合约在部署或者执行的时候都要缴纳一定的手续费，分为部署费用和执行费用。

部署费用是指开发者将一个智能合约部署到区块链上需要向区块链系统支付一定的费用（目前是 500NEO 币）。

执行费用使用者每执行一条智能合约的指令都会向 NEO 系统支付一定的执行费用（目前是免费）。

## 一些简单的智能合约

下面是一些简单的继承自 VerificationCode 的智能合约

```c#
public static bool Verify()
{
	return true;
}
```

该合约的返回值永远为 true，表示任何人都可以花费这个合约地址里的资产（可以理解为撒钱）。

NEO 钱包客户端中有一个删除资产的功能，当你删除了一个资产，这个资产是发送到了一个指定的地址中，这个地址就是上述智能合约所生成的合约地址，任何人都可以花费这个地址里的资产，当然这个地址里的资产都是别人不想要的资产。

```c#
public static bool Verify()
{
	return false;
}
```

该合约的返回值永远为 false，表示这个合约里的资产无人能使用（可以理解为烧钱或销毁一笔资产），比如里面可以存储一些已注销的公司的股权。

更多示例请查看：

[Hello World](tutorial/HelloWorld.md)

[Lock（锁仓合约）](tutorial/Lock.md)

[Domain（域名系统）](tutorial/Domain.md)

