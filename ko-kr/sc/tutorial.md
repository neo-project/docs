# 네오 스마트 계약 설명서 (NEO smart contract tutorial)

먼저 번의 설명서를 읽으셨으면 비주얼 스튜디오 2015의 C#을 이용해서 스마트 계약 프로젝트를
작성할 수 있습니다. 여기서는 NeoVM (Neo Virtual Machine)상에서 어떻게 스마트 계약이 
실행되는 지 살펴보겠습니다.

## 스마트 계약 발동 조건(triggers)

스마트 계약 발동 조건에는 두 가지가 있습니다 : 

1. 계약 사용자 증명(Authentication) : 스마트 계약이 계약 계좌(contract account)에 있고, 사용자가 자산 상의 계약을 사용하고자 할 경우, 스마트 계약이 발동됩니다.

2. 수동으로 전송을 하고 스마트 계약을 호출 하는 경우 : 사용자가 스마트 계약을 작동시키기 위해 전송(Invocation Transaction)을 하는 경우 스마트 계약이 발동됩니다. 

## 스마트 계약의 형태(type)

네오 스마트 계약에는 두 가지 기본적인 클래스가 있습니다. 함수코드(FunctionCode)와 입증코드(VerificationCode)입니다.

### 함수코드에서 상속된 스마트 계약

기능코드에서 상속된 스마트 계약은 다른 사용자들이 컴파일 해서 블록체인상에 배포할 수 있습니다. 이는 프로그래밍에 있어서 ‘함수’의 개념과 같으며, 사용 시에 “주(main)함수(위에서 설명한 스마트 계약)”로 호출(call)될 수 있고 또 다른 함수(입증코드에서 상속되는 스마트 계약)로 호출될 수 있습니다. 
스마트 계약의 시작 포인트로 함수코드에서 상속하는 것이 일반적인 방법입니다. 이때 리턴 값은 빈값(Void), 정수(int) 또는 바이트(byte)가 됩니다. 이상이 이 함수코드 의 상세 내용입니다.

아래는 함수코드에서 상속된 계약의 디폴트 값입니다

```c#
public class Contract1: FunctionCode
{
    public static void Main ()// Note that the main method to capitalize
    {
    // The Smart Contract inherited from FunctionCode can be compiled and posted to the block chain for use by other users
    }
}
```

### 입증 코드(VerificationCode)에서 상속된 스마트 계약

입증코드에서 상속된 스마트 계약은 지갑클라이언트에 연락처를 생성하며, 사용자가 이 연락처안의 자산을 사용하고자 할 경우, 스마트 계약을 발동시킵니다. (사용자가 연락처 내의 자산을 사용하는 전송을 보내는 경우)

스마트 계약의 리턴 값이 참(true)인 경우, 증명이 확인되고, 사용자는 자산을 쓸 수 있습니다. 스마트 계약의 리턴 값이 거짓(flase)인 경우, 증명이 실패되며, 사용자는 자산을 쓸 수 없습니다. 증명이 실패된 전송은 다른 노드에 의해 배포될 수 없으며, 컨센서스(concensus) 노드가 확인해주지 않습니다. 

아래는 입증코드에서 상속된 스마트 계약의 예입니다. 이 입증 방법의 리턴 값은 반드시 ‘bool’이라고 나와야 합니다.

```c#
public class Contract1: VerificationCode
{
    public static bool Verify ()
    {
    Return true;
    }
}
```

## 네오 가상 머신 (NeoVM, Neo Virtual Machine)

NeoVM은 네오 스마트 계약을 실행하는 가상 머신입니다. 여기서는 이러한 개념에서 가성 머신을 좁은 의미에서 다룰 것입니다. 일반적으로 말하는 Vmware나 Hypster-V같은 운영 체제나 그에 준하는 프로그램들에 대해서는 다루지 않겠습니다.

예를 들면, 자바에서 쓰는 JVM이나 .NET CLR의 경우 소스코드는 해당되는 바이트코드(bytecode)로 컴파일 된 다음 각기 해당하는 가상 머신에서 실행됩니다. JVM과 CLR은 실제 머신에서 명령어를 수행하는 것과 비슷한 방식으로 바이트코드를 실행합니다. 현저하게 바이너리(binary)명렁어들은 여전히 실제 머신에서 실행됩니다. 실제 머신은 메모리에서 명렁어들을 가지와서 버스를 통해 CPU로 보낸 다음에 디코딩, 실행한 후 결과를 저장합니다.

### 가상 머신 구조(architecture)

   ![](/assets/neo-vm.jpg)

위의 그림은 네오 가상 머신의 구조를 보여줍니다. 점선 박스안의 부분이 네오 가상 머신의 코어입니다.

#### 실행 엔진 (Execute engine)

오른 쪽 녹색 부분은 가상 머신의 실행 엔진(실제 머신에서의 CPU와 같은 의미)에 해당하며, 플로우 컨트롤(flow control), 스택 연산(stack operation), 비트 연산(bit operation), 대수 연산, 로직 연산, 암호화 과정과 상호 운영(interoperable) 서비스 레이어(아래 부분에서 설명) 등을 실행합니다. 

#### 스텍 계산

회식 가운데 부분은 가상 머신의 스텍 계산 영역(메모리에 해당)으로 가상 머신은 이 부분에 스텍에 기반을 두는 방법과 레지스터에 기반을 두는 두 가지 방법으로 저장할 수 있으며 두 방법 다 나름의 장/단점이 존재합니다. 스텍에 기반을 둔 가상 머신은 JVM과 CPython, .NET CLR등이 있으며 레지스터에 기반을 둔 VM들은 Dalvik과 Lua 5.0같은 것들이 있습니다. 스텍 기반의 가상 머신들은 실제 연산 시 실제 머신 스텍과 직접 상호작용하는 방식으로 작동합니다. 

디폴트가 데이터를 연산수(operand)스텍에서 가져오기 때문에 별도의 연산수를 지정할 필요가 없습니다. 예를 들면 x86 어셈블리의 경우, “ADD EAX, EBX”의 경우 사용자는 연산이 어디서 시작하는 지, 또 결과가 어디에 저장되어야 하는 지 지정해야 합니다. 그러나 스텍 기반의 가상 머신의 명령어에서는 이런 과정이 필요 없습니다. 예를 들어 간단한 연산을 추가하기 위해 디폴트 연산수가 해당 연산수 스텍에 저장되며, 해당 스텍에서 추가 연산을 위한 두 데이터를 직접적 끄집어 낼 수 있습니다. 


#### 상호 운영 (Interoperable) 서비스 레이어

오른쪽 파란 색 부분은 가상 머신의 상호 운영 서비스 레이어(주변장치(peripheral)에 해당)입니다. 
현재, 이 상호 운영 서비스 레이어는 스마트 계약의 체인-체인 데이터에 접근하기 위한 API들을 제공하는데, 이 API들은 블록 정보, 전송 정보, 연력처, 자산 정보 등에 접근 할 수 있습니다. 

추가적으로 이 상호 운영 사비스 레이어는 각각의 계약에 대해 지속적인(persistent) 저장장소를 제공합니다.
각 스마트 계약은 선택적으로 개인 저장소(private storage)를 생성하는데, 이는 영구 저장소의 컨텍스트(context)안이 아니라, 해당 계약 호출받는 쪽 의해 결정되는 키 밸류 오브젝트의 형태(form) 안에 존재합니다. 물론 호출하는 쪽에서 그쪽의 저장 컨텍스트를 호출되는 쪽에 전해줄 수 있고(인증을 완료하기 위해) 호출하는 쪽에서 읽고 쓰는 연산을 수행할 수 있습니다.

### 부과 모드 (Charge mode)

스마트 계약은 특정 비용을 전개(deployment) 비용과 실행(implementation) 비용으로 나누어  부과할 수 있게 프로그램될 수 있습니다. 

전개 비용은 개발자가 스마트 계약을 블록체인상에 전개할 때 지불하는 비용입니다. (현재 500GAS), 사용자는 스마트 계약을 실행할 때 필요한 실행 비용을 지불할 수 있습니다. (현재는 무료)

## 간단한 스마트 계약

아래는 입증 코드에서 상속되는 스마트 계약입니다.

```c#
public static bool Verify ()
{
Return true;
}
```

위 계약의 리턴 값은 항상 참이며, 누구든 이 연락처 주소에 있는 자산을 사용할 수 있음을 의미합니다. (‘돈’으로 이해될 수 있음)

클라이언트의 전자지갑 내 자산을 삭제할 수 있는 함수가 있습니다. 사용자가 자산을 삭제 시, 해당 자산은 특정주소로 이전되며, 이 주소는 위의 스마트 계약에 의해 생성됩니다. 

```c#
public static bool Verify ()
{
Return false
}
```

위 스마트 계약의 리턴 값은 항상 거짓입니다. 이는 해당 계약의 자산이 사용될 수 없음을 의미합니다. (자산의 파기) 이는 마치 취소된 회사의 지분과 같습니다. 

아래에 더 많은 예제들이 있습니다 : 

[Hello World](tutorial/HelloWorld.md)

[Lock (lock)](tutorial/lock.md)

[Domain (Domain Name System)](tutorial/Domain.md)
