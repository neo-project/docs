# 네오컨트랙트 백서 (NeoContract Whitepaper)

## 1. 머리말

스마트 계약은 미리 프로그램 된 계약(Contract)을 자동적으로 수행하는 컴퓨터 프로그램을 참조합니다. 스마트계약의 
개념은 1994년 닉 스자보 (Nick Szabo)가 제안했으며 이는 인터넷의 역사만큼이나 오래되었습니다. 그러나 당시의 안정적인
실행환경의 부재로 인해 스마트 계약은 그렇게 널리 퍼지지 못했습니다. 

사토시 나카모토(Satoshi Nakamoto)라는 사람이 2008년에 비트코인을 발표하면서 블록체인의 개념을 잡았습니다. 나카모토는
일련의 프로그램 언어 스크립트를 사용해서 사용자들의 개인 계좌와 전송 과정에 좀 더 유연성을 가질 수 있도록 하였는데 이는
결국 체인에 기반을 둔 배아기 형태의 스마트 계약 시스템이 되었습니다. 

2014년 비틸릭 부테린(Vitalik Buterin)이라는 10대 소년이 이더리움을 발표했는데 이는 체인에 기반을 둔 완벽한 튜링과 
다양한 형태의 탈중앙화 블록체인 어플리케이션들에 이용될 수 있는 스마트 계약 시스템을 제공합니다. 


네오 블록체인은 보다 새로운 스마트 계약인 네오컨트렉트를 제공하는 어플리케이션 플랫폼인 동시에 디지털 자산을 의미합니다.
네오 플렛폼의 기저에서부터 해당 네트워크는 디지털 자산의 일종인 네오어셋(NEO-Asset)과 사용자들이 손쉽게 디지털 사업에
참여할 수 있게 해주는 디지털 인증인 네오아이디(Neo-ID)와 같은 여러 가지 기능들을 제공하면서 더 이상 해당 체인의 네이티브 
토큰의 확인하는 과정에 머무르지 않습니다. 

여기에서는 네오컨트랙트의 여러 특징들과 더불어 비 기술적인 다른 내용들도 소개할 것입니다. 네오에 사용된 기술적인 요소들에 대한 상세 내용이 필요하시면 다음의 링크로 가시길 바랍니다:
docs.neo.org.

## 2. 특징 (Features)

## 2.1 확실성 (Certainty)

하나의 프로그램이 서로 다른 컴퓨터에서 실행될 경우, 또는 하나의 컴퓨터에서 서로 다른 시간대에서 실행되는 경우, 언제나
같은 결과값이 나온다고 보장할 수 있는 지의 여부에 따라 해당 프로그램의 가치가 결정됩니다. 

블록체인은 다편화된 저장공간이며 컴퓨터를 활용하는 방법입니다. 이러한 분산된 시스템내부의 데이터는 신뢰성 있는 계산의 
결과이며 변경될 수 없습니다. 스마트 계약은 분산된 블록체인의 다양한 노드 내부에서 수행됩니다. 만약 스마트 계약이 
비결정론적이면 다양한 노드에서 나오는 결과들은 시로 일관성을 가지지 않을 것입니다. 이 결과 노드들 사이의 협의가 이루어
지지 않음에 따라 해당 네트워크는 정체되게 됩니다. 그렇기 때문에 스마트 계약 시스템을 설계함에 있어 비결정론적인 상황을
야기할 수 있는 요소를 제거하는 것이 반드시 필요합니다. 

### 2.1.1 시간

시간을 확보하는 것은 매우 일반적인 기능입니다. 이는 시간에 민감한 특정 계약들에 매우 중요하게 적용될 수 있습니다. 
그러나 시간을 확보하는 것은 비결정론적인 기능이며, 분산된 시스템상에서 노드들 간에 서로 통일된 정확한 시간을 가지게
하는 것은 어렵습니다. 네오컨트랙트는 전체 블록 체인을 처리하는 데 있어 블록 기반의 시스템 호출 기능을 제공하는데 
이는 타임스탬프(Timestamp)서버로 작동하며 언제든 새로운 블록이 만들어 질 때마다 해당 타임스탬프를 확보합니다. 
평균적으로 네오 네트워크 는 매 15초마다 새로운 블록을 생성하며 스마트 계약들은 이 +-15초의 오차 범위 안에서 
얻을 수 있는 가장 최근의 블록 타임을 기반으로 실행됩니다.

#### 2.1.2 임의성 (Randomness)

도박 프로그램이나 작은 게임들 같은 많은 프로그램들은 임의의 난수(Random number) 발생 기능을 가지고 있습니다. 그러나
이러한 난수 발생 기능은 각각의 시스템 마다 서로 다른 결과를 초래하는 대표적인 비결정론적인 방법입니다. 분산된 시스템
에서는 이러한 문제를 푸는 여러 가지 방법들이 있습니다 : 먼저 모든 노드에 같은 난수 씨앗 (Seed)를 사용할 수 있는데 이렇게 함으로써 전체 난수 발생기능은 같은 순서로 작동하게 됩니다. 그러나 이 방법은 미리 전체 난수 발생 결과를 노출 시키게 되며 난수라는 그 자체의 가치를 매우 협소하게 합니다. 다른 방법은 난수를 발생시키는 데 있어 모든 노드들이 서로 커뮤니케이션
하게 하는 것입니다. 이는 암호방법론적인 기술을 이용하는데 꽤 괜찮은 난수 기능을 제공합니다. 그러나 단점으로 실행속도가
매우 느리며 각 노드별로 미리 통신을 해야 하는 번거로움이 있습니다. 중앙화된 난수 발생 기능은 만들어지는 난수들에 대해
효율성과 일관성을 지니게 하지만 이 방법의 결점은 너무나 명백한데, 사용자들이 무조건적으로 중앙화된 난수 제공 처를 신뢰해야 하는 것입니다. 

네오에서는 난수를 발생시키는 두 가지 방법이 있습니다 : 1) 각각의 블록이 생성될 때 해당 컨센서스 (Consensus) 노드는 난수
에 대해 협의를 해서 해당 블록의 임시 영역 (Nonce field)에 그것을 채워 넣습니다. 그렇게 함으로써 해당 계약 프로그램은 
임의의 블록에 대해 임시 영역을 참조함으로써 해당 난수를 얻을 수 있습니다. 2) 계약 프로그램은 해당 블록의 해쉬 값을
난수 발생장치로 이용할 수 있습니다. 왜냐하면 블록 해쉬 값은 특정 난수를 상속받기 때문입니다. 다만 이 방법으로 만들어지는 
난수는 그렇게 강력하진 않습니다. 


#### 2.1.3 데이터 소스 (Data Source)

만약 프로그램이 실행 중에 데이터를 얻게 되면 데이터 소스가 비 결정인 지 아닌 지에 따라 비 결정성 프로그램이 될 확률이 
높습니다. 예를 들면 서로 다른 서치 엔진을 사용하여 특정 검색어에 대한 최상위 10개의 검색결과를 비교하면 배열 순서, 그리고
사용자의 IP주소에 따라 서로 다르게 나올 확률이 매우 높습니다. 

네오는 스마트 계약을 위해 두 가지 형태의 결정론 적 데이터 소스를 제공합니다. 

**(1) 블록체인 원부 (Blockchain Ledger)**

계약 절차는 공동 이용할 수 있는 서비스를 통해 각 체인의 각종 영역 및 전체 전송내역 등을 포함한 체인 상에 존재하는 
모든 데이터에 접근할 수 있습니다. 해당 블록의 데이터는 결정론적이며 서로 일관성을 가지고 있기 때문에 스마트 계약들이
확실하게 이용할 수 있습니다. 

**(2) 계약 저장 공간 (Contract Storage Space)**

네오 네트워크상에 개시된 각 계약들은 해당 계약만이 접근 가능한 개별의 저장 공간을 가집니다. 네오의 협의 (Consensus) 절차로
인해 네트워크 상의 각각의 노드는 해당 노드별 저장 상태에 일관성을 가지게 됩니다. 

만약 비 블록체인(non-blockchain) 데이터에 접근해야 할 경우, 네오는 그러한 데이터와 직접적으로 상호작용하게 하지 않습니다. 
비 블록체인의 데이터는 전송기능을 통해 네오 블록체인으로 이동되며, 해당 스마트 계약이 이용할 수 있게 앞서 설명한 데이터
소스들 중의 하나로 전환됩니다. 

#### 2.1.4 계약 호출 (Contract Call)

네오컨트렉트의 스마트 계약들은 상호간에 호출할 수 있는 기능을 가지고 있으나 반복적으로 호출되지는 않습니다. 
반복과정은 해당 계약 안에서만 가능하며 현재 계약 외부에서는 발생하지 않습니다. 스마트 계약들 간의 호출 관계는 정적이어야
합니다 : 목표는 특정 실행시간을 지정할 수 없습니다. 이러한 특징은 실행되기 전에 해당 프로그램의 작동양식을 충분히 
한정시키며 해당 호출 관계는 해당 프로그램이 실행되기 전에 충분히 정의되어야 합니다. 이러한 특성에 기반해서 다양한
계약들이 동적으로 분할되며 병렬적으로 실행됩니다. 

### 2.2 높은 성능 (High Performance)

스마트 계약의 실행 환경은 계약의 성능적인 관점에 있어서 매우 중요한 역할을 합니다. 여러분이 하나의 실행 환경 성능을
분석할 때, 중요한 두 가지 평가 요소가 있습니다 : 1) 명령의 실행 속도 2) 실행 환경 자체의 초기 시동 속도.
스마트 계약에 있어 실행 환경은 명령의 실행 속도보다 종종 더 중요하게 취급됩니다. 스마트 계약은 이러한 명령어들이 
손쉽게 최적화 될 수 있다는 면 때문에 좀 더 로직의 IO연산에 연관되어 있습니다. 매번 스마트 계약이 호출 될 때마다, 새로운
가성 머신/컨테이너를 가동시켜야 합니다. 그 결과 작업 환경(가상 머신/컨테이너를 시작하는)의 실행 속도가 스마트 계약의 
성능에 지대한 영향을 끼칩니다.

네오는 스마트 계약 실행 환경으로써 경량(lightweight)의 NeoVM이라는 가상 머신을 사용하는 데, 이는 시작 속도가 매우 빠르고
리소스 소모량이 매우 적기 때문에 스마트 계약 같은 짧은 프로그램에 완벽하게 대응합니다. JIT(실시간 컴파일러)를 통한 핫스팟
스마트 계약의 저장(caching)과 컴파일 편집을 사용함으로써 가상 머신의 효율을 극대화 시킬 수 있습니다.

### 2.3 확장성 (Scalability)

#### 2.3.1 높은 병행성 과 동적인 분할 (High Concurrency and dynamic partitioning)

시스템의 확장성을 논할 때, 두 가지 영역이 포함됩니다 : 수직 확장성과 수평 확장성입니다. 수직 확장성은 현 장비의 총 용량을
충분히 활용하면서 프로세싱 작업 흐름(workflow)를 최적화하는 작업을 참조합니다. 이러한 접근법은 단일 시스템의 하드웨어에
의존하기 때문에 쉽게 시스템의 한계까지 도달합니다. 우리가 시스템을 확장할 필요가 있을 때는 일련의 시스템들을 병렬구조로
바꿀 수 있는 방법은 없을까요? 이론적으로 시스템의 개수를 늘려야 하며 이렇게 계속하면 무한대까지 늘릴 수 있을 지도
모릅니다. 그렇다면 분산된 블록체인 상에서 무한대의 확장성을 확보할 순 없을까요? 다른 말로, 블록체인을 병렬구조로 실행할
수 없을까요?

블록체인은 다양한 종류의 데이터를 기록하고 이러한 데이터들의 변경을 통제하는 분산된 원부(ledger)입니다. 스마트 계약은 
이러한 규정(rule)들을 저장하는 매개체로 사용됩니다. 다양한 스마트 계약들이 순차적인 질서 없이 동시 다발적으로 수행하듯이
블록체인은 프로그램을 병렬적으로 실행(process)할 수 있습니다. 기본적으로 계약이 서로 간에 상호작용이 없다면, 또는 해당
계약이 동시에 같은 상태의 데이터를 변경하지 않는다면, 그 계약들의 실행은 비순차적이며 동시에 수행될 수 있습니다. 
다른 말로, 단순히 일련의 순서에 따라 연속적으로 실행하기만 한다면 해당 네트워크는 수평적으로 확장될 수 없습니다.

위에 분석에 기반해서 무한한 확장성을 가진 스마트 계약 시스템을 설계할 수 있습니다. 우리가 해야 할 일은 간단한 규칙
몇 가지를 정하기만 하면 됩니다. 

**(1) 하나의 스마트 계약은 해당 계약이 속해있는 상태 기록만 변경 가능합니다;**

**(2) 동일 전송 배치(블록)에서는 하나의 계약은 한번만 실행됩니다.**

이 결과, 순차적 구성은 결과에 영향이 없기 때문에 모든 스마트 계약은 병렬적으로 실행 될 수 있습니다. 그러나 만약
"하나의 스마트 계약은 해당 계약이 속해있는 상태 기록만 변경 가능하다"면 이는 해당 계약은 서로 간에 호출 할 수 없는
것을 내포하며, 고립된 상태를 초래할 것입니다. 만약 "동일 전송 배치(블록)에서는 하나의 계약은 한번만 실행된다"면 이는
해당 스마트 계약에서 발생한 디지털 자산은 한 블록당 전송이 한번만 가능하다는 의미를 내포하게 됩니다. 이렇게 된다면
스마트 계약이 더 이상 '스마트'하지 않게 되는 것을 의미할 것입니다. 최종 적인 우리의 설계 목적은 상호 계약간의 호출과
같은 블록, 같은 호출 안에서 다양한 실행을 갖게 하는 것입니다. 

다행히도, 네오의 스마트 계약은 정적인 호출 구조를 가지고 있기 때문에, 호출 목표는 실행 시간을 지정할 수 없습니다.
이는 프로그램이 실행 전에 프로그램의 행동양식을 충분히 한정시켜 주며, 이러한 호출 관계는 실행 이전에 충분히 확정되어
집니다. 우리는 각각의 계약들이 명백하게 호출하고 싶어하는 계약을 지정하게 하는 것이 필요하며 그렇게 함으로써 실행 
환경 (operating environment)은 계약 절차를 실행하기에 앞서 완벽한 콜 트리(call tree)를 계산할 수 있으며, 콜 트리에 
기반해서 해당 계약들을 분할 실행할 수 있습니다. 같은 상태 정보를 변경할 수 있는 계약들은 같은 분할 영역(partition)안
에서는 순차적인 구성으로 실행되는 반면, 다른 분할 영역에서는 병렬적으로 실행 됩니다. 

#### 2.3.2 낮은 연결성 (Low coupling)

연결성은 두 개 이상의 개체(entity)간의 의존성의 척도입니다. 네오컨트랙트 시스템은 저 연결성 디자인을 가지는 NeoVM을
활용하는데, 이는 공동 이용(interoperable) 서비스 레이어를 통해서 비 블록체인(non-blockchain)데이터와 정보를 교환합니다. 
그 결과 '스마트 계약' 기능의 대다수 업그레이드는 공동 이용 서비스의 API를 늘림으로써 이루어집니다.  

## 3. 계약 이용 (Contract Use)

### 3.1 계약 증명 (Contract Verification)

비트 코인에서 사용되는 퍼블릭 키 계좌 시스템과 달리, 네오 계정 시스템은 계약 계좌 시스템을 사용합니다. 네오에서 
각각의 계좌는 하나의 증명 계약에 대항하며, 증명 계좌의 해쉬 값은 해당 계좌 주소입니다 : 이 증명 계좌 프로그램의 로직은
계좌의 소유권을 조정합니다. 한 계좌로부터 전송을 하는 경우, 사용자는 먼저 그 계좌의 증명 계약(validation contract)
을 실행해야 합니다. 증명 계약은 일련의 변수(parameters) (디지털 서명이나 다른 것들)들을 승인하고 증명 후 연산 값을 
돌려보내면서 해당 시스템에서 그 증명이 성공적으로 수행된 것을 나타냅니다. 

사용자는 먼저 해당 블록체인에 대해 증명 계약을 사용할 수 있거나, 전송 과정 중에 해당 계약 내용을 인증(publish)할 수 있습니다.

### 3.2 계약 적용 (Contract Application)

계약 적용은 특별한 전송에 의해 발동되는데, 이는 해당 시스템의 실행 시 에서 해당 계약 (저장 공간) 개별 상태와 광역(global)
상태에 접근하거나 변경이 가능합니다. 예를 들면 사용자는 해당 계약이 실행되는 동안 계약, 투표, 데이터 저장의 
광역 디지털 자산을 생성하고 동적으로 새로운 계약도 생성할 수 있습니다. 

이 계약 적용의 실행에는 비용이 필요합니다. 전송 요금이 소모되면, 계약은 실패하며 실행이 중지됩니다. 그리고 상태 변경은 이전 상태로 복귀됩니다. 이 계약의 성공은 해당 전소의 유효성에 영향을 주지 않습니다. 

### 3.3 계약 기능 (Contract Function)

이 계약 기능은 일반적으로 사용되는, 다른 계약들을 호출하는 기능들을 제공하는 데 사용됩니다. 해당 스마트 계약 코드는 
재활용될 수 있고, 그렇게 함으로써 개발자들은 점점 더 복잡한 비지니스 로직을 작성할 수 있습니다. 각각의 계약 기능은 
이행 시, 향후 계약에서 일관성을 가지기 위해 읽기 또는 쓰기를 위한 개별 저장 공간을 선택할 수 있습니다.

이 계약 기능은 실행되기 위해선 해당 체인이 미리 선 이행되어야 하며 더 이상 사용되지 않을 경우 '자기 파괴' 기능을 통해 그 체인에서 제거 되야 하고 해당 개별 저장 더 이상 사용되지 않기에 파기될 것입니다. 예전 계약 데이터는 계약 이송 툴을 통해
파괴되기 전에 또 다른 하위계약(subcontract)으로 자동적으로 이전될 수 있습니다. 

## 4. 가상 머신 (Virtual Machine)

### 4.1 가상 하드웨어

NeoVM은 스마트 계약을 실행하기 위한 가상 하드웨어 레이어를 제공합니다.

**(1) CPU**

CPU는 명령 흐름 조정 기능, 산술 연산 그리고 로직 연산 등에 의하여, 계약 내부의 명령어의 순차 실행과 읽기를 담당합니다.
이러한 CPU 기능의 미래는 JIT기능(실시간 컴파일러)의 도입으로 확장 될 수 있으며 그럼으로써, 명령어 수행의 효율성이 증가할 것입니다. 

**(2) 호출 스택 (Call Stack)**

호출 스택은 각 기능 호출에서 프로그램 수행의 전후 관계 정보를 유지하는 데 사용됩니다. 이렇게 함으로써 프로그램이 
해당 기능의 실행이 끝나고 되돌아간 후에 현재 전후 관계 내에서 연속적으로 실행 할 수 있게 됩니다. 

**(3) 계산 스택 (Calculation Stack)**

모든 NeoVM의 런타임 데이터는 다른 명령어들의 이행이 끝난 후 계산 스택안에 저장되며, 이 스택은 작업 수행의 데이터
요서들에 맞춰서 계산됩니다. 예를 들면 추가적인 명령어를 실행 시, 이 추가부분에 관련된 두 개의 연산이 이 계산 스택
에서 추출되며, 이 추가 부분의 결과는 해당 스택의 가장 윗부분으로 위치합니다. 기능 호출 변수들도 마찬가지로 오른쪽에서
왼쪽으로 스택의 순서에 맞춰서 계산됩니다. 이 기능이 성공적으로 수행되면 스택 추출 기능(fetch function)은 해당 값을 
돌려보냅니다.

**(4) 스페어 스택 (Spare Stack)**

여러분이 스택 내에서 요소들을 재배열 하거나 스케줄을 작석할 때, 해당 요소를 임시로 스페어 스택에 저장한 다음 추후에 
불러낼 수 있습니다. 

### 4.2 명령어 셋 (Instruction set)

NeoVM은 스마트 계약 프로그램을 작성할 수 있는 일련의 간단하고 실용적인 명령어들을 제공합니다. 기능에 따라 아래와
같이 분류될 수 있습니다. 

(1) 상수 명령어 (Constant Instruction)

(2) 프로세스 조정 명령어 (Process Control Instruction)

(3) 스택 운영 명령어 (Stack Operation Instruction)

(4) 스트링 명령어 (String Instruction)

(5) 로직 명령어 (Logic Instruction)

(6) 산술 연산 명령어 (Arithmetic Operation Instruction)

(7) 암호화 명령어 (Cryptographic Instruction)

(8) 데이터 연산 명령어 (Data Operation Instruction)

NeoVM명령어들에서 스마트 계약의 암호화 알고리즘의 효율을 최적화 하는 데 사용되는 ECDSA, SHA등과 같은 암호화 명령어
들을 지원하는 데 주목할 필요가 있습니다 덧붙여, 데이터 조작 (manipulation) 명령어들은 직접 적으로 데이터 구조를 배열하고
복잡화하는 것을 지원합니다. 

### 4.3 상호운영 서비스 레이어 (Interoperable service layer)

스마트 계약이 실행되는 이 가상 머신은 모래상자 환경인데 모래상자 바깥에 있는 데이터에 접근하는 경우나, 실행 중인
데이터를 지속적으로 유지할 때 상호운영 서비스 레이어가 필요합니다. 상호운영 서비스 레이어안에서, 네오 컨트랙트는 
스마트 계약 프로그램을 이용해서 일련의 시스템 기능과 서비스들을 열람할 수 있고 다른 정상적인 기능들처럼 
이러한 계약들에 접근하거나 호출할 수 있습니다. 모든 시스템 기능들은 동시 다발적으로 수행되기 때문에 확장성에 대해 
염려할 필요가 없습니다. 

### 4.4 디버깅 기능

간혹 쓸만한 테스팅/디버깅 방법들의 부재로 스마트 계약의 개발이 어려울 때가 있습니다. NeoVM은 사용자가 계약 코드, 단독
(single) 스텝, 단독 운영 등의 중단점을 설정할 수 있는 가상 머신 레벨 상에서 프로그램 디버깅을 지원합니다. 가상 머신과
해당 블록체인과의 저 결합성 디자인 덕분에 NeoVM에 최종 제품 환경과 일치하는 시험 환경을 제공하기 위해 직접적으로 
다양한 IDE들을 쉽게 통합시킬 수 있습니다.

## 5. 고 수준 언어 (High level language)

### 5.1 C#, VB .NET, F#

네오컨트랙트를 사용하는 개발자들은 본인들이 익숙한 거의 모든 언어들을 사용할 수 있습니다. 가장 처음으로 지원하는 
언어들은 C#, VB .NET, F# 등이었습니다. 우리는 이러한 언어들에 대해 컴파일러와 플러그인 들을 제공하고 있으며 여러분은 이런 고수준 언어를, NeoVM이 지원하는 해당 명령어들로 편집(compilation)할 수 있습니다. 편집과정 동안 컴파일러는 
MSIL(Microsoft intermediate language)에 초점을 두기 때문에 이론적으로 어떠한 .NET 언어라도 MSIL언어로 변환되어
직접적으로 지원 가능하게 됩니다. 

엄청나게 많은 수의 개발자들은 이러한 언어들에 능숙하고 위의 언어들은 매우 강력한 개발 환경을 지니고 있습니다. 
개발자들은 비주얼 스튜디오 안에서 개발/디버깅을 할 수 있습니다. 우리는 개발자들이 쉽게 시작하도록 최대로 활용할 수 
있는 스마트 계약 작성 템플렛을 제공합니다. 

### 5.2 자바, 코트린(Kotlin)

자바와 코트린은 두 번째 지원하는 언어들입니다. 우리는 개발자들이 네오 스마트 계약 어플리케이션을 개발하는 데 있어
JVM 기반의 언어를 사용하기 위한 컴파일러와 IDE플러그인을 제공합니다. 

자바는 폭넓게 사용되고 있으며 코트린은 최근 안드로이드 개발에 있어 구글의 공식 추천언어가 되었습니다. 우리는 이러한 
지원함으로써 네오 스마트 계약 개발자 수를 획기적으로 늘릴 수 있다고 확신합니다. 

### 5.3 다른 언어들

향후 네오컨트랙트는 컴파일러 개발 과정의 난이도에 따라 다른 고 수준의 언어들을 추가할 예정입니다. 그 중 몇몇 언어들은
이미 지원하고 있을 지도 모릅니다. 

(1) C, C++, GO

(2) Python, JavaScript

향후, 이러한 고 수준 언어들에 대한 지원을 계속 늘려갈 것입니다. 우리의 목표는 90%이상의 개발자들이 새로운 언어를 배우는
일없이 네오컨트랙트를 개발할 수 있게 하는 것이며, 이미 존재하는 상용 시스템 코드도 직접적으로 블록체인에 변환전송
할 수 있게 하는 것입니다. 

## 6. 서비스

### 6.1 블록체인 원부 (ledger)

네오스마트컨트렉트는 상호운영 서비스를 통해 제공되는 시스템 기능을 통해 네오 블록체인에 대해 온전한 블록과 전송 기록, 
런타임 당시의 각 필드들을 포함하는 완료된 블록 데이터를 획득할 수 있습니다. 
사용자는 특히 아래의 데이터들을 조회(query)할 수 있습니다. 

(1) 블록체인의 높이(height)

(2) 블록 헤드, 현재 블록

(3) 전송

(4) 전송의 종류, 특성, 입력 값, 출력 값, 등등

이러한 데이터들을 통해 여러분은 자동 배당금, 업무량 증명(Proof of workload)에 기반한 스마트 계약 등과 같은 
재미있는 어플리케이션들을 개발 할 수 있습니다. 

### 6.2 디지털 자산

디지털 자산 인터페이스 제공하는 상호 운영 서비스를 통해, 스마트 계약은 네오블록체인의 특성들과 여러 디지털 자산의 통계에
대해 조회할 수 있을 뿐만 아니라, 해당 계약의 실행 시간 동안 새로운 디지털 자산을 생성할 수 있습니다. 스마트 계약을 통해 
생성된 디지털 자산은 해당 계약 외부로 발행/전송/거래될 수 있습니다. 이러한 자산은 네오상의 원래 자산과 동일하며, 네오와
호환되는 지갑 소프트웨어에 의해 관리될 수 있습니다. 이러한 특정 인터페이스는 아래사항들을 포함합니다. 

(1) 자산 특성 조회(inquiry)；

(2) 자산 통계 질문(query)；

(3) 자산 라이프 사이클 관리 : 생성,변경, 파기 등등；

(4) 자산 관리 : 다양한 언어 상의 이름, 전체 변경, 정밀 변경, 관리자 내부의 변경；

### 6.3 지속성(Persistence)

네오 블록체인의 각 스마트 계약 프로그램들은 개인 저장 공간 내부에서 해당 프로그램이
읽고 쓸 수 있습니다. 스마트 계약은 그 프로그램의 만의 스토어(Store)에서 읽기/쓰기/변경/삭제 에 대한 권한을 가지고 있습니다. 
이러한 데이터들은 주요 가치 쌍(key-value pairs)의 형태로 저장되며 아래와 같은 인터페이스를 가지게 됩니다.

(1) 모든 저장 기록의 횡단 (Traverse all the records stored)

(2) 특정 키(Specified Key)에 따라 해당 기록 돌려보내기

(3) 특정 키에 따라 새로운 기록의 작성 및 변경

(4) 특정 키에 따라 해당 기록 삭제

일반적으로 계약은 그에 해당되는 저장영역에서만 읽기/쓰기가 가능한데, 한가지 예외가 있습니다. 계약이 적용될 때, 그 적용된
계약은 호출한 계약이 제공하는 인증을 가지고 크로스 도메인 요청을 통해 호출 계약의 저장 공간에 접근할 수 있습니다. 덧붙여,
계약 실행 시에 동적으로 생성된 하위계약(Subcontract)에 대해 모계약(Parent contract)은 그 저장 공간에 바로 접근 가능합니다. 

크로스 도메인 요청은 네오컨트랙트로 하여금 풍부한 라이브러리 역량을 갖추게 해주는 데 이는 호출 계약에 대해 고도로 확장 가능한 
데이터 관리 능력을 제공합니다.
 
## 7. 요금 (Fees)

### 7.1 사용 요금 (Deployment Fee)

네오의 분산된 아키텍처는 저장 용량의 많은 중복성을 제공하며 이런 용량을 이용하는 것에는 비용이 청구됩니다. 네오 네트워크
상에서 스마트 계약을 사용하는 비용은 현재 500GAS이며 이는 시스템 징수액의 형태로 모금됩니다. 향후 비용은 시스템의 실제
연산에 맞춰 조정될 것입니다. 블록체인상에서 사용되는 스마트 계약은 계약 이행자가 해당 계약을 파기할 때까지 여러 번 이용될 수 있습니다.

### 7.2 실행 요금 (Implementation Fee)

네오는 스마트 계약에 있어서 신뢰할 만한 실행 환경(execution environment)을 제공하며, 계약의 실행에는 각각의 노드 별로
컴퓨터 자원이 사용됩니다. 그렇기 때문에 사용자들은 스마트 계약의 실행에 대해 비용을 지불해야 합니다. 이 비용은 각 실행 별
소모되는 컴퓨터 자원에 기반해서 결정되며, 비용의 단위는 GAS입니다. 만약 GAS가 부족해서 해당 스마트 계약이 실행되지 않을 
경우 이제까지 소모된 비용은 반환되지 않는데 이는 네트워크 자원소모를 초래하는 악의적인 공격을 막기 위함입니다. 

대부분의 단일 계약에 대해, 실행비용이 10GAS미만인 경우에  무료로 실행되기 때문에 사용자는 비용을 상당히 아낄 수 
있습니다.

## 8. 어플리케이션 시나리오

### 8.1 초전도 전송 (Superconducting Transactions)

블록체인 상의 디지털 자산은 본질적으로 어느 정도의 유동성(liquidity)를 가져야 하는데, 일반적인 차례 차례(point to point)
일어나는 전송은 충분한 유동성을 제공하지 않습니다. 그래서 거래소는 사용자들에게 거래(trading) 서비스를 제공해야 합니다.
디지털 자산 거래소들은 두 개의 카테고리로 나뉘어 집니다: 1) 중앙 집중식 거래소, 사용자들은 디지털 자산을 거래소에 예치
해야 하며, 그 다음 웹사이트에서 보류된 주문들이 차례 차례 진행됩니다. 2) 탈 중앙화 거래소, 거래 시스템이 블록체인으로
구송되어 있으며 거래소는 매칭(matching) 서비스를 제공합니다.

중앙 집중식 거래소는 효율이 뛰어나며 다각적인 서비스를 제공합니다. 그러나 거래소 자체에 대한 신뢰도가 보장되어야 하는데,
그렇지 않을 경우 사용자 자금 횡령, 사기 같은 모랄 해저드 문제가 생깁니다. 이에 반해 탈 중앙화 거래소는 이러한 문제가 
없는데 반해 사용자 경험이 매우 빈약하며, 효율성에서 병목현상이 생기기 쉽니다. 이 두 가지 형태에서 장점만을 결합할 수는 
없을까요?

초전도 전송이 위의 질문에 대한 답일 될 수 있습니다: 사용자는 블록체인 상의 그들의 자산을 바로 사용할 수 있기 때문에 
별도로 자산을 예치할 필요가 없습니다. 전송자체는 블록체인에서 완료되나, 매칭 과정은, 중앙 집중식 거래소에 의해
체인 외부에서 이루어집니다. 매칭이 체인 외부에서 이루어지기 때문에, 효율성 면에서 중앙 집중식 거래소와 유사하나, 해당
디지털 자산은 사용자의 권한 하에 존재합니다. 거래소는 매칭 서비스를 수행하는 데 있어 사용자의 거래 의도를 활용하며, 여기에
횡령, 사기 같은 모랄 해저드가 개입될 여지는 없습니다.

현재 네오 커뮤니티 내부에서 청 고래(blue whale) 소싱같은 블록체인의 초전도 전송을 위한 스마트 계약의 개발이 대두되고
있습니다. 

### 8.2 스마트 자금 (Fund)

블록체인에 기반한 스마트 자금은 전통적인 자금형태에 비해 탈 중앙화, 개방성 그리고 투명성이라는 장점 및 고도의 보안성과 
자유도를 가지고 있습니다. 이런 스마트 자금에는 국경이 없으며 전세계 투자들이 쉽게 참여할 수 있습니다. 훌륭한 프로젝트
들은 전세계적으로 자금을 모을 수 있습니다. 

네오컨트랙트 기반의 네스트(Nest)는 스마트 자금 프로젝트인데, 이더리움 기반의 DAO 프로젝트와 매우 유사하나, 해킹을 
당했던 DAO와는 달리 매우 향상된 보안 체제를 지니고 있습니다. 

### 8.3 크로스 체인 상호 운영성 (Interoperability)

가까운 시일 안에 전세계 적으로 사설 체인, 연합 체인 그리고 퍼블릭 체인들이 존재하게 될 것입니다. 이러한 고립된 블록 
체인들은 '가치'(value)와 정보 측면에서 섬과 같은데, 이는 서로 간에 상호 운영이 안되기 때문입니다. 크로스 체인 상호 
운영성을 통해 수많은 고립된 체인들이 서로 연결될 수 있으며 서로 다른 체인상에 존재 하던 '가치'들이 교환되어 진정한
인터넷의 '가치'가 될 수 있습니다. 

네오컨트렉트는 크로스 체인 상호운영성을 지원하며, 크로스 체인 자산 교환, 분산된 전송 그리고 서로 다른 체인 상의 
스마트 계약의 실행들에 있어 일관성을 보증합니다. 

### 8.4 오라클 머신 (Oracle Machines)

설화에서의 오라클은 특정 질문에 대한 초자연적인 대답에 의존하는 것인데, 블록체인 상에서의 오라클 머신은 스마트 계약을
위한 바깥 세상으로의 문을 여는 역할을 합니다. 스마트 계약을 위해 실제 세상의 정보를 실행 조건으로 사용할 수 있게
해줍니다.

네오컨트랙트에 인터넷 상의 자원 같은 외부 데이터에 직접적으로 접근할 수 있게 하는 기능은 없습니다. 왜냐하면 그렇게 할
경우 계약을 실행하는 동안 노드들 간의 일관성을 해치는 비결정론적 행동양식을 초래할 수 있기 때문입니다. 네오컨트렉트에
오라클 머신의 실행에는 신뢰할 수 있는 서드 파티 (third party)가 해당 외부 데이터를 블록체인으로 보내야 하며, 이러한 
데이터들은 블록체인 원부의 한 부분으로 통합되어야 합니다. 이렇게 함으로써 비결정론적 결과가 초래되는 것을 방지할 수 
있습니다. 

위에서 언급한 신뢰할 만한 서드 파티는 계약 당사자들 간의 상호 신뢰할 수 있는 한 개인이나 기관이 될 수 있거나 아니면
경제적 인센티브를 보장 받을 수 있는 탈 중앙화된 데이터 제공처가 될 수 있습니다. 이러한 방식으로 네오컨트렉트는 오라클
머신을 사용합니다. 

### 8.5 이더리움 뎁(dAPP)

비트코인은 블록체인과 전자 화폐의 시대를 열었고, 이더리움은 스마트 계약의 시대를 열었습니다. 블록체인 스마트 계약의
선구자인 이더리움은 스마트 계약 시스템의 기술적 현실화와 경제 모델 그리고 디자인 개념의 정립에 지대한 공을 세웠습니다.
동시에 이더리움 플랫폼은 여러 산업 분야에서 널리 사용되는 다음의 기능들이 포함되는 엄청난 수의 
dAPP(distributed application)을 출현시켰습니다; 도박 동의 (gambling agreement), 디지털 자산, 전자 황금 (Electronic gold),
 게이밍 플랫폼, 의료 보험, 결혼(marriage) 플랫폼 등등.
 
이론상, 이러한 모든 dAPP들은 NEO 어플리케이션의 형태로 네오컨트렉트 플랫폼 안으로 손쉽게 이식될 수 있습니다. 
