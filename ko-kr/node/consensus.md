# 컨센서스 (동의:Consensus)

## 1 – 용어 설명

* **지분에 대한 증명(Proof of Stake)** `PoS` - 장애 허용(fault tolerance)을 처리하는데 있어 네트워크 컨센서스를 사용하는 알고리즘(algorithm)

* **작업에 대한 증명(Proof of Work)** `PoW` - 장애 허용을 처리하는데 있어 컴퓨팅 파워를 사용하는 알고리즘

* **비잔틴 장애(Byzantine Fault)** `BF` - 노드가 운영 중이지만 불순한 목적으로 사용되고 있는 것을 의미하는 장애(failure)

* **위임된 비잔틴 장애 허용(Delegated Byzantine Fault Tolerance)** `DBFT` - 내고장성을 확보하기 위해 네오 블록체인에서 도입한 컨센서스 알고리즘

* **뷰(View)** `v` - 네오 DBFT에서 컨센서스 활동 중 사용되는 데이터셋

## 2 – 역할(Roles)
**네오 컨센서스 알고리즘 에서, 컨센서스 노드는 네오 소유자들에 전송의 타당성에 대한 투표를통해 선출됩니다. 이런 컨센서스 노드들을 ‘북키퍼’(bookkeeper)라고 합니다. 앞으로 이들을 컨센서스 노드라고 하겠습니다.**

  - <img style="vertical-align: middle" src="/assets/nNode.png" width="25"> **컨센서스 노드** - 이 노드는 컨센서스 활동에 참여하고 있습니다.  컨센서스 활동 중, 컨센서스 노드들은 아래 두 역할을 차례로 수행합니다:
  - <img style="vertical-align: middle" src="/assets/speakerNode.png" width="25"> **발표자** `(하나)` - 해당 **발표자**는 시스템에 제시 안 블록(block proposal) 전송에 책임이 있습니다.
  - <img style="vertical-align: middle" src="/assets/cNode.png" width="25"> **대리인** `(다수의)` - **대리인**들은 해당 전송에 대한 컨센서스 도달에 책임이 있습니다.
  
  
## 3 – 소개(Introduction)

타 블록체인들에 대한 주요 차이점중의 하나는 네트워크에서의 거짓 행위와 결함(defective)들에 대한 처리 방법입니다. 

일반적인 방법은 POW를 사용하여, 네트워크 대다수의 컴퓨터 파워가 정직하게 작동하는 방식으로 보장하는 것입니다. 그러나 이 개념은 컴퓨팅 파워에 의존하기 때문에, 매우 비효율적입니다. (컴퓨팅 파워에는 컴퓨터 하드웨어와 전기, 에너지가 필요합니다) 이런 POW에 의존한 방식은 여러 가지 제한이 생기며, 확장 시 비용이 많이 듭니다. 

네오는 위임된 비잔틴 장애 허용 컨센서스(DBFT : Delegated Byzantine Fault Tolerance) 알고리즘을 가지고 있습니다. 이 DBFT는 POS방식의 장점을 취해서(네오 소유자들의 **컨센서스 노드**에 대한 투표) 최소한의 자원만을 사용해서 문제가 되는 이슈를 거부하는 방식으로, 네오 네트워크를 비잔틴 장애로부터 보호합니다. 이 방법을 통해 현 블록체인 상의 비잔틴 장애로 부터 네트워크를 보호하면서 성능 향상과 확정성 확보라는 두마리 토끼를 잡을 수 있습니다. 

## 4 – 이론(Theory)

비잔틴 장군 문제는 분산된 컴퓨팅에서 발생할 수 있는 전형적인 문제입니다. 이는 일정한 수의 **대리인(delegate)들**이 **발표자(speaker)**의 순서에 맞춰 모든 컨센서스(consensus, 동의)가 이루어져야 할 때 발생하는 문제입니다. 이러한 체계에서는 어떤 **발표자**나 **대리인**들이 배신을 할 수 있기 때문에 우리는 매우 신중해야 합니다. 거짓(dishonest) 노드가 각 수신자에게 일치하는 메시지를 보내지 않게 되면 최악의 상황이 발생하게 됩니다. 이 문제의 해법은 각 **대리인**들에게 해당 **발표자**가 정직한지 그리고 해당 그룹의 실제 명령(command)이 무엇인지 증명을 요구하는 것입니다. 

DBFT가 어떻게 작동하는 지 설명하기 위해, 이 부분을 섹션5에 있는 66.66% 동의율(consensus rate)의 타당성에 대해 초점을 맞출 것입니다. 여러분께서 유념하실 부분은 거짓 노드가 반드시 불순한 의도를 가지고 활동하는 것을 의미하는 것만이 아니라 원래의 의도대로 작동하지 않는 노드도 의미한다는 것입니다. 

토론을 하기 위해 두가지의 시나리오를 가정하겠습니다. 이 시나리오들에서, 각 노드는 해당 **발표자**에게서 수신한 메시지를 송신합니다. 이 방식은 매우 중요하며 DBFT에서도 쓰이는 방식입니다. 우리는 여기서 정상적인 작동을 하는 시스템과 비정상적인 작동을 하는 시스템간의 차이를 설명합니다. 자세한 내용은 아래 참조를 보시기 바랍니다. 

### **정직한 발표자(Honest Speaker)**

  <p align="center"><img src="/assets/n3.png" width="300"><br> <b>그림 1:</b> n = 3 거짓 <b>대리인</b>.</p>

 **그림 1**에서 우리는 하나의 충실한 **대리인**이 있습니다.(50%) 양측 **대리인**모두 정직한 **발표자**로부터 같은 메시지를 받았습니다. 그러나 한 **대리인**이 거짓이기 때문에 정직한 대리인은 단지 거짓 노드가 있다는 것만 알 수 있지, 해당 블록이 **발표자**에게서 오는 지 거짓 대리인에게서 오는 지 알 수 없습니다. 이렇기 때문에 그 **대리인**은 투표에서 제외되어야 하며, **뷰**(dataset)를 바꿔야 합니다.
  
  <p align="center"><img src="/assets/n4.png" width="400"><br> <b>그림 2:</b> n = 4 거짓 <b>대리인</b>.</p>
  
 **그림 2**에서, 우리는 두 명의 충실한 대리인이 있습니다.(66%) 모든 **대리인**들이 정직한 **발표자**로 부터 같은 메시지를 받았으며 그들이 그 발표자에게 받은 메시지와 같이 그들의 검증 결과를 보냅니다. 두 정직한 **대리인**들의 동의(consensus)에 기반해서 우리는 **발표자**가 맞는 지 아니면 **대리인**이 거짓인 지 알 수 있습니다.
  
### **거짓 발표자(Dishonest Speaker)** 
  
  <p align="center"><img src="/assets/g3.png" width="300"><br> <b>그림 3:</b> n = 3 거짓 <b>발표자</b>. </p>
  
 **그림 3**에서, 거짓 발표자에 대해, 우리는 **그림 1**에서 묘사한 것과 같은 동일한 결과를 얻습니다. 어느 **대리인**도 해당 노드가 거짓인지 판단할 수 없습니다.  
  
  <p align="center"><img src="/assets/g4.png" width="400"><br> <b>그림 4:</b> n = 4 거짓 <b>발표자</b>. </p>
  
 **그림 4**에서 처럼, 가운데와 오른쪽 노드에서 받은 블록은 검증되지 않습니다. 그들은 66%를 확보해야 하기 때문에, 새로운 **발표자**를 뽑는 **뷰**가 나올 때까지 연기하게 됩니다. 이 예에서, 만약 거짓 **발표자**가 세 명의 **대리인**중 두 명에게 정직한 데이터를 보냈다고 한다면, **뷰**를 변경할 필요 없이 그 데이터는 검증될 수 있습니다.   

## 5 – 실용적인 이행(Practical Implementation)

네오의 DBFT 시스템은 동의가 이루어진 사실을 보장하기 위해 반복적인 동의 방법(iterative consensus method)을 실용적으로 사용하고 있습니다. 이 알고리즘의 성능은 시스템 내의 정직한 노드의 부분(fraction)에 의존합니다. **그림 5**는 거짓 노드의 부분의 기능의 예상되는 반복을 보여줍니다. 


**그림 5**는 **컨센서스 노드**의 정직성(honesty)이 66.66%이하인 경우에는 해당되지 않습니다. 이 지점과 33% 정직성 사이에는 컨센서스가 달성될 수 없는 무인지대가 있습니다. **컨센서스 노드** 정직성이 33.33%이하에선 거짓 노드들이 그들 사이에서 컨센서스를 달성할 수 있으며(그 노드들이 서로 일치한다면) 그 시스템에서 새로운 진실(truth)이 될 수 있습니다.


<img src="/assets/consensus.iterations.png" width="800">

**그림 5** DBFT알고리즘의 몬테 카를로(Monte-Carlo) 시뮬레이션을 통해 컨센서스에 이를 때까지 필요한 반복수에 대한 설명(100 노드; 정직한 노드 에서 무작위로 뽑은 100,000개의 시뮬레이트 된 블록)

### 5.1 – 정의(Definitions)

**알로리즘에 대해 아래의 사항들을 정의합니다:**

  - `t`: 블록 생성에 할당된 시간, 초 단위로 측정됨.
    - 현재: `t = 15 초`
	-  이 값은 대략적으로 하나의 **뷰** 반복기간에 사용됩니다. 컨센서스 활동과 이벤트 커뮤니케이션은 이 시간 상수보다 상대적으로 빠릅니다.

	
  - `n`: 활동하는 **컨센서스 노드**의 숫자.
 
	
- `f`: 시스템 내의 장애 있는**컨센서스 노드**의 최소 임계치. 
  	- `f = (n - 1) / 3`
  
	
- `h` :컨센서스 활동중의 현재 블록 높이(block height).

	
  - `i` : **컨센서스 노드** 지수(index).
  
  
- `v` : **컨센서스 노드의**의 **뷰**(dataset). 이 뷰는 컨센서스 라운드동안 해당 노드가 받은 집계된 정보가 들어있습니다. 여기에 모든 **대리인**들이 발행한 투표(`prepareResponse` or `ChangeView`)가 포함됩니다.


  - `k` : ‘v’의 지수. 하나의 컨센서스 활동에는 다수의 라운드가 필요합니다. 컨센서스가 실패하면 ‘k’는 자연증가하고 컨센서스 시작을 위해 새 라운드가 시작됩니다.

  
- `p` : **발표자**로 선출된 **컨센서스 노드**의 지수. 이 지수는 하나의 노드가 시스템 내에서 독재하는 것을 막기 위해 **컨센서스 노드**들을 돌아가면서 계산하는 방식을 가지고 있습니다. 

	- `p = (h - k) mod (n)`
  

  - `s`: 안전한 컨센서스 임계치.  이 임계치 이하의 해당 네트워크는 실폐할 수 있습니다..  
  	- `s = ((n - 1) - f)`


### 5.2 – 요구사항(Requirements)

**네오 내부에는 컨센서스 장애 허용에 대한 세 개의 기본 요구사항이 있습니다.**

1.	`s`**대리인**들은 블록이 실행되기 이전에 해당 전송에 대해 동의(consensus)해야 합니다.

2. 거짓 **컨센서스 노드**는 거짓 전송에 대해 정직한 컨센서스 노드를 설득할 수 없습니다.

3. 최소한 `s` **대리인**들이 컨센서스 활동을 하기 위해 같은 상태에 있어야 합니다.(`h`,`k`)


	
### 5.3 - 알고리즘
**이 알고리즘은 아래와 같이 작동합니다.**

1. 하나의 **컨센서스 노드**는 전체 네트워크에 송신자의 서명을 포함한 전송을 보냅니다.

   <p align="center"><img src="/assets/consensus1.png" width="450"><br> <b>그림 6:</b> 하나의 <b>컨센서스 노드는</b> 전송을 받아 시스템 전체에 보냅니다. </p>
   
  
2. **컨센서스 노드**는 전송 데이터를 로컬 메모리에 기록합니다.

3. 컨센서스 활동의 첫째 **뷰**는 초기화됩니다.

4. 해당 **발표자**가 확인됩니다.

	 <p align="center"><img src="/assets/consensus2.png" width="450"><br> <b>그림 7:</b> A <b>발표자</b>가 확인되고 뷰가 정해집니다. </p>
	
  `t` 초 동안 **기다립니다**.
	
5. 해당 **발표자**는 제안사항을 전체 시스템에 방송합니다 :
    <!-- -->
        <prepareRequest, h, k, p, bloc, [block]sigp>

	 <p align="center"><img src="/assets/consensus3.png" width="450"><br> <b>그림 8:</b> 해당 <b>발표자는</b> 제시 안에 대한 블록을 만들어 내고<b>대리인</b>그것을 검토합니다. </p>
	 
6. 해당 **대리인**들은 그 제시 안을 받아 검증합니다 :

    - 데이터의 포맷은 시스템 규칙을 따르는가?
    - 해당 전송이 이미 해당 블록 내에 존재하는 가?
    - 해당 계약 스크립트(contract scripts)가 정확하게 실행되었는가?
    - 해당 전송이 단지 하나의 지불만을 포함하는가? (즉, 해당 전송이 이중 지불 시나리오를 방지하는가?)

    - **만약 검증된 제시 안이 뿌려진다면(Broadcast):**
	    <!-- -->
	        <prepareResponse, h, k, i, [block]sigi>
	 	
    - **만약 검증되지 못한 제시 안이 뿌려진다면 :**
	    <!-- -->
	        <ChangeView, h,k,i,k+1>
			
   <p align="center"><img src="/assets/consensus4.png" width="500"><br> <b>그림 9:</b> 해당 <b>대리인</b>들이 제시 안 블록을 검토하고 대응합니다. </p>

7. ‘s’수에 해당하는 'prepareResponse' 전송에 대해 수신한 후에, 하나의 **대리인**은 컨센서스를 이루고 블록을 발행(publish)합니다.

8. 해당 **대리인**들은 그 블록을 서명합니다.

   <p align="center"><img src="/assets/consensus5.png" width="500"><br> <b>그림 10:</b> 컨센서스가 이루어 졌고 동의하는 <b>대리인</b>들이 그 블록을 서명하고 체인에 결속시킵니다. </p>
  
8. **컨센서스 노드**가 풀 블록을 수신하면, 현재 **뷰**데이터는 소거되고 새 라운드의 컨센서스가 시작됩니다.
	- `k = 0`
 
--- 
  
**주의:**
 
 만약 컨센서스 없이 같은 **뷰**상에서 (![timeout](/assets/consensus.timeout.png) )  초가 지나면:
  - **컨센서스 노드** 아래를 시스템에 뿌립니다(broadcast):

	<!-- -->
	    <ChangeView, h,k,i,k+1>
		
- **컨센서스 노드**가 최소 ‘s’수에 해당하는 동일한 **뷰**의 변경 조짐을 보이는 신호를 받으면, ‘v’뷰가 새 컨센서스 라운드를 발동하면서 자연 증가합니다.
	


	

## 6 - 참조
1. [블록체인을 위한 비잔틴 장애 허용 알고리즘](https://www.neo.org/Files/A8A0E2.pdf)
2. [실용적인 비잔틴 장애 허용](http://pmg.csail.mit.edu/papers/osdi99.pdf)
3. [비잔틴 장군 문제](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/The-Byzantine-Generals-Problem.pdf)

