# NEO スマートコントラクト チュートリアル

ここまでのチュートリアルを読んで、Visual Studio 2015でC#を使用してスマートコントラクトプロジェクトの作成できるようになりました。ここでは、NeoVM (Neo仮想マシン)上でどのようにしてスマートコントラクトを実行する方法について説明します。

## スマートコントラクトの開始

スマートコントラクトを開始するには2つの方法があります：

1. コントラクトユーザー認証： スマートコントラクトはコントラクトアカウントであり、ユーザーがアセット内でコントラクトアカウントを使用するように要求すると、スマートコントラクトが開始されます。

2. 手動でトランザクションコールを送信するスマートコントラクト： ここで、スマートコントラクトの実装を開始するトランザクション（呼び出しトランザクション）を送信します。

## スマートコントラクトの種類

スマートコントラクトには、`FunctionCode`（機能コード）と`VerificationCode`（検証コード）の2つの基本クラスがあります。

### FunctionCodeから継承されたスマートコントラクト

`FunctionCode`から継承されたスマートコントラクトは、他のユーザーが使用できるようにコンパイルしてブロックチェーンに配布することができます。これは、プログラミングの「関数」に相当し、 「メイン関数」（上述の2つのスマートコントラクト呼び出し）によって呼び出すことができ、「他の関数」（`FunctionCode`から継承した他のスマートコントラクト）によって呼び出すこともできます。

`FunctionCode`から継承されたスマートコントラクトのエントリポイントは`Main`メソッドです。 戻り値は`void`、`int`、または`byte`にすることができます。 この記事は、上記のコードの詳細な説明になります。

`FunctionCode`から継承されたデフォルトコントラクトは次のとおりです:

```c#
public class Contract1: FunctionCode
{
    public static void Main ()// C#のMainは大文字で始まります
    {
        // FunctionCodeから継承されたスマートコントラクトをコンパイルし、他のユーザーが使用できるようにブロックチェーンに公開することができます
    }
}
```

### VerificationCodeから継承されたスマートコントラクト

`VerificationCode`から継承されたスマートコントラクトは、ウォレットクライアント内でコントラクトアドレスを生成することができます。コントラクトアドレスでアセットを使用する場合（ユーザーがコントラクトアドレスのアセットを使用してトランザクションを送信した場合）、スマートコントラクトが開始されます。

コントラクトから`true`の値が返されると、検証がパスされ、ユーザーはアセットを使用できます。 コントラクトが`false`の値を返すと、検証は失敗し、ユーザーはアセットを使うことができません。 検証に失敗したトランザクションは別のノードによってブロードキャストできず、コンセンサスノードによって承認されません。

ここでは、`VerificationCode`から継承したスマートコントラクトの例を示します。 `Verify`メソッドの戻り値は `bool`型でなければなりません。

```c#
public class Contract1: VerificationCode
{
    public static bool Verify ()
    {
        Return true;
    }
}
```

## NeoVM （NEO仮想マシン）

NeoVMは、NEOスマートコントラクトコードを実行する仮想マシンです。 オペレーティングシステム、またはVmwareやHyper-VなどのOSをシミュレーションするプログラムのようなものではなく、狭義の仮想マシンのコンセプトを意味します。

たとえば、Java JVMまたは.Net CLRでは、ソースコードがバイトコードにコンパイルされ、対応する仮想マシン上で実行されます。 JVMまたはCLRは、実際の物理マシン上で命令を実行するのと同様のバイトコードを実行します。 特に、対応するバイナリ命令はそのまま物理マシン上で実行します。 物理マシンは、メモリから命令を取り出し、バス（Bus）を介してCPUに転送し、結果をデコード、実行、格納します。

### 仮想マシンアーキテクチャ

   ![](/assets/neo-vm.jpg)

上記の図は、Neo仮想マシン（NeoVM）のシステムアーキテクチャ図です。破線ボックスの内側は仮想マシンのコアです。

#### 実行エンジン

左側の緑エリアは、相互運用可能なサービスレイヤー（後述）で、フロー制御、スタック操作、ビット操作、算術演算、論理演算、暗号化などの一般的な命令を実行できる仮想マシン実行エンジン（CPUに相当）です。

#### 計算スタック

グレーの中間部分は仮想マシンの計算スタック（メモリに相当）であり、今日の仮想マシンには、独自の長所と短所を持ち、またそれぞれに象徴的な特徴のある、スタックベースとレジスタベースの2つの実装があります。 JVM、CPython、および.Net CLRはスタックベースの仮想マシンであり、DalvikやLua5.0などのレジスタベースの仮想マシンも存在します。 スタックベースの仮想マシンには、実際の操作を実行するときに仮想マシンがスタックと直接対話できるコンセプトを持ちます。

デフォルトでは、オペランドスタックからデータをフェッチするため、オペランドを指定する必要はありません。 たとえば、x86アセンブリの "ADD EAX, EBX"は実装の中に、どこから操作を行う必要があるか、また、その結果をどこに格納するかを指定する必要があります。 しかし、スタックベースの仮想マシン命令では、これらのパラメータを指定する必要はありません。 たとえば、単純な演算を追加するために、デフォルトのオペランドがオペランドスタックに格納されます。スタックから2つのデータを直接ポップして加算することができます。

#### 相互運用可能なサービスレイヤー

右側の青い部分は、仮想マシンの相互運用可能なサービスレイヤー（周辺機器と同等）です。 現在、相互運用可能なサービスレイヤーは、ブロック情報、取引情報、契約情報、資産情報などにアクセスできるスマートコントラクトのチェーンデータにアクセスするためのいくつかのAPIを提供しています。

さらに、相互運用可能なサービスレイヤーは、各コントラクトに永続的な記憶領域を提供します。 それぞれのスマートコントラクトは、オプションとして、永続ストアのコンテキストではなく、契約先の呼び出し先によって決定されるkey-valueオブジェクト形式のプライベートストレージを使用して作成されます。 もちろん、呼び出し元は、呼び出し元に独自の記憶域コンテキストを渡す必要があります（承認を完了するため）、呼び出し元は読み取りと書き込み操作を実行できます。

### チャージモード

スマートコントラクトは、導入コストと実行コストに分けられた一定の料金を請求するようにプログラムすることができます。

導入コストとは、開発者がブロックチェーンにスマートコントラクトをデプロイするために、ブロックチェーンシステムに支払う必要のある料金を指します（現在500GAS）。 実行コストは、ユーザーごとがスマートコントラクトの実行のための料金（現在は無料）を支払います。

## 単純なスマートコントラクト

ここでは、`VerificationCode`を継承したシンプルなスマートコントラクトの例をを示します。

```c#
public static bool Verify ()
{
    Return true;
}
```

ここでは、コントラクトの戻り値は常に`true`であり、誰でもアセットのコントラクトアドレスを使うことができることを示しています。（お金の支払いに例えることできます）

NEOクライアントウォレットには資産を削除する機能があります。 アセットを削除すると、アセットは指定されたアドレスに送信されます。これは上記スマートコントラクトによって生成されたコントラクアドレスであり、誰でもアドレスを使用できます。

```c#
public static bool Verify ()
{
    Return false
}
```

コントラクトの戻り値は常に`false`であり、このコントラクトの資産は、会社が株式の一部を保管することができるように、使用不能（資産の焼却または破壊に例えることできます）であることを示しています。

その他の例については、以下を参照してください:

[Hello World](tutorial/HelloWorld.md)

[Lock (ロック・コントラクト)](tutorial/lock.md)

[Domain (ドメインネームシステム)](tutorial/Domain.md)
